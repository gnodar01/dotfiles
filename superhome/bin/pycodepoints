#!python

import sys

# f[rom] <fmt> t[o] <fmt>
# fmt: ( c[odepoint] | d[ecimal] | u[nicode] | b[ytes] | n[ame] )
# from default: codepoint
# to default: unicode
# codepoint formats (case insensitive): 0x00ae | u+00a2 | \u00a2 | 00a2
# decimal fromat: decimal equivilent of codepoint, e.g. 162
# unicode: the literal unicode character, e.g. Â¢
# bytes: the byte encoding of the unicode, e.g. \xc2\xa2

#codepoints = []
#for c in contents:
#    c = c.strip()
#    if c:
#        print(ord(c),hex(ord(c)),c)

def exit_err(msg):
    parser.print_usage(file=sys.stderr)
    print(f"fansi: error: {msg}", file=sys.stderr)
    parser.exit(2)

if __name__ == "__main__":
    import select
    import argparse

    choices = [
        ("c", "codepoint"),
        ("d", "decimal"),
        ("u", "unicode"),
        ("b", "bytes"),
        ("n", "name"),
    ]
    formats = {
        choices[0][0]: choices[0],
        choices[0][1]: choices[0],
        choices[1][0]: choices[1],
        choices[1][1]: choices[1],
        choices[2][0]: choices[2],
        choices[2][1]: choices[2],
        choices[3][0]: choices[3],
        choices[3][0]: choices[3],
        choices[4][1]: choices[4],
        choices[4][1]: choices[4],
    }

    parser = argparse.ArgumentParser(
             prog="pycodepoints",
             description=r"""
Converts from a unicode representation to another one
                
    bytes are always delimited by \x, whitespace is ignored

    codepoints can be delimited by 0x, 0X, u+, U+, \u, \U
        or every length n hex is taken, where n is specified by the -l flag;
        whitespace is always ignored

    name, decimal, and unicode can have custom delimiters, but by default it is \n
             """,
             formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("-f", default="unicode", choices=formats.keys(), help="from format")
    parser.add_argument("-t", default="codepoint", choices=formats.keys(), help="to format")
    parser.add_argument("-s", "--delim", default="\n", help="delimiter to use for unicode, name, and decimal; default is \\n")
    parser.add_argument("filename", nargs="?")

    args = parser.parse_args()

    # determine if stdin is available for reading
    # this is just the select syscall; man select
    # this method is preferable to sys.stdin.isatty becaus it works even in the
    # case of remote invocation (eg ssh)
    rlist,_,_ = select.select([sys.stdin],[],[],0)

    if args.filename is not None:
        f_stream = open(args.filename, "rb")
    elif len(rlist) != 0:
        f_stream = sys.stdin.buffer
    else:
        parser.print_usage(file=sys.stderr)
        print("provide one of stdin or filename", file=sys.stderr)
        exit(1)

    if len(args.delim) != 1:
        parser.print_usage(file=sys.stderr)
        print("delim must be a single character")
        exit(1)
    delim = args.delim.encode('utf8')
   
    bcontents = b""
    if args.f in formats["b"]:
        from functools import reduce
        bcontents = reduce(
            lambda x,y: x+y,
            map(
                lambda c: int(c, 16).to_bytes(1,'big'),
                filter(
                    lambda c: c not in [b'', b' ', b'\t', b'\n'],
                    f_stream.read().lower().split(b'\\x')
                )
            ),
            b''
        )
    elif args.f in formats["d"]:
        bcontents = ''.join(map(
            lambda c: chr(int(c)), f_stream.read().split(delim)
        )).encode('utf8')
    elif args.f in formats["u"]:
        bcontents = f_stream.read()

    if args.filename is not None:
        f_stream.close()
        
    print(bcontents)

